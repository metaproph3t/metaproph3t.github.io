<!DOCTYPE HTML>
<html>

<head>
    <title>Proph3t's homepage</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <link media="all" href="/styles.css" type="text/css"
          rel="stylesheet" />
</head>

<body>
    <h1>Proph3t's homepage</h1>
<p>
<a href="https://metaproph3t.github.io">About</a>
</p>
<p>
<a href="https://themetadao.org">The Meta-DAO Project</a>
</p>

<hr />
    <div class="comp">

    <h2>A better oracle design?</h2>
    <p>
    	I've come up with what I think is a novel oracle design. It may give
	better game-theoretic guarantees than existing designs. I'm going to
	explain it in the context of a binary oracle where there are two options,
	such as 'who won the US presidential election in 2024.' Generalizing it
	to non-binary oracles, such as price fees, is left as an exercise to the
	reader :)

    <p>
    	The main problem with blockchain oracles is that oracle providers may
	maliciously provide incorrect data. This is concerning because
	<a href="https://compound.finance/">billions</a>
	<a href="https://www.coingecko.com/en/coins/dai">of</a>
	<a href="https://aave.com/">dollars</a>
	<a href="https://synthetix.io/">of</a>
	<a href="https://docs.solend.fi/protocol/oracles">capital</a>
	could be lost if an oracle does provide incorrect data. The existing
	approach is generally to increase the number of oracle nodes, which
	should reduce the risk that they are able to collude and mount an
	attack. Maybe <a href="https://switchboardxyz.medium.com/introduction-to-switchboard-serverless-8c0edf7fad91">
	Switchboard</a> will ameliorate this with <a href="https://en.wikipedia.org/wiki/Trusted_execution_environment">TEEs</a>, but I think the jury is still out on whether a TEE-centric oracle network will work.

    <p>
    	A naive solution to this problem is to simply slash oracle nodes that
	provide incorrect data. The problem with this approach is defining which
	data is correct and which is incorrect. You can really only slash nodes
	for not giving the <i>consensus</i> result.

    <p>
    	To take an exmaple, imagine that the oracle in question is 'who won the
	US presidential election in 2020?' If 7/9 of the oracles responded 'Joe
	Biden' and 2/9 responded 'Donald Trump,' we can slash the two with the
	incorrect result. <i>The problem arises when the majority of nodes give
	a spurious response. In this case, we would slash the nodes who provided
	a correct response.</i> This is a major problem because it incentivizes
	oracles to provide what they believe the consensus response will be. In
	the absence of communication between nodes, the actual truth would be a
	a <a href="https://en.wikipedia.org/wiki/Focal_point_(game_theory)">Schelling point</a>
	and nodes are likely to give the correct response. However, malicious
	individuals or groups can game this system by submitting an incorrect
	response early. That way, the other nodes will be incentivized to follow-on
	with more incorrect responses, or at least withold their vote if possible.

    <p>
    	If we want to adopt a slashing-based approach, we must make collusion
	very hard or impossible. Specifically, we must make it very hard for
	nodes to broadcast what answer they will select before all nodes have
	made their selection.

    <p>
    	The solution to this is a hash-based commit-reveal scheme. During the
	commit phase, oracle nodes determine what the correct response is
	and select a random nonce. They then hash these together, and submit
	this hash to the chain. In pseudo-code, this looks like the following:

    <pre>
    <code>
	let nonce = random_number()
	let who_won = get_who_won()
	let commit = hash([nonce, who_won])
	submit_to_chain(commit)
    </code>
    </pre>

    <p>
    	During the commit phase, any node can be slashed if their nonce is
	revealed. Slashed stake is redistributed pro rata to the other nodes.
	Once all nodes have submitted commits, the oracle enters a reveal
	phase. During the reveal phase, nodes have time <i>t</i> to reveal
	the nonces they used to compute the commits, which in turn reveals
	their vote (Joe Biden in this case).

    <p>
    	It is very hard for nodes to reveal what they will vote for before all
	nodes have committed to a response. If a committed node proves to an
	uncommitted node that they have committed to a certain response by
	revealing their nonce, the uncommitted node can submit this nonce to
	the chain to receive their pro-rata share of slashing the committed node.
	On the other hand, if the committed node uses a 'just trust me bro'
	style of proof, the uncommitted node runs the risk that the committed
	node is trying to trick them into submitting a non-consensus vote so that
	the committed node can collect their pro-rata share of slashing the
	uncommitted node. So either way, the transaction costs of collusion are
	too high.

    <p>
    	Further, nodes can't collude with tit-for-tat because a node must 'bet
	the farm' in a collusion-attempt. This makes it a <a href="https://en.wikipedia.org/wiki/Finite_game">
	finite game</a>, where tit-for-tat is not the equillibirium. 

    <p>
    	So yeah, I think this is a pretty cool design. I'm not sure what kind of
	feeds this would be good or bad for. I'm pretty sure that the commits and
	reveals would need to be in separate blocks, which wouldn't allow
	one-update-per-slot oracles like Pyth provides on Solana. I'm not even
	sure how this would exactly work for prices. Maybe you slash nodes that
	are more than 5% away from the consensus median? But this does seem like
	it would work well for binary oracles that aren't super-real-time, like
	presidential election results.

</html>
