<!DOCTYPE HTML>
<html>

<head>
    <title>Proph3t's homepage</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <link media="all" href="/styles.css" type="text/css"
          rel="stylesheet" />
</head>

<body>
    <h1>Proph3t's homepage</h1>
<p>
<a href="https://metaproph3t.github.io">About</a>
</p>
<p>
<a href="https://themetadao.org">The Meta-DAO Project</a>
</p>

<hr />
    <div class="comp">

    <h2>Yet Another Limit Order Book</h2>
    <p>
    	Yesterday, there were three open-source spot <a href="https://en.wikipedia.org/wiki/Central_limit_order_book">CLOB</a>
	implementations:
	<a href="https://github.com/project-serum/serum-dex">Serum</a>,
	<a href="https://github.com/openbook-dex/openbook-v2">Openbook v2</a>, and
	<a href="https://github.com/Ellipsis-Labs/phoenix-v1">Phoenix v1</a>.
	Today, I release a <a href="https://github.com/metaDAOproject/YALOB">fourth</a>,
	appropriately named Yet Another Limit Order Book (acronymized to YALOB).
	Here's the story of how this one came to be:

    <p>
    	As a small cadre of individuals knows, I'm working on
	the Meta-DAO, a DAO that will use <a href="http://mason.gmu.edu/~rhanson/futarchy.html">futarchy</a>
	to make decisions. Early on in the implementation of
	the Meta-DAO's program, I encountered a problem. In order to implement futarchy programatically,
	I needed to be able to fetch the prices of assets on-chain.
	Specifically, I needed to pull 10-day time-weighted average prices on
	<a href="https://github.com/metaDAOproject/Manifesto/blob/main/Manifesto.pdf">conditional member tokens</a>.
	But here's the problem: <i>no existing CLOB implementation provides 
	time-weighted average prices</i>. Or at least, no CLOB that I could use.
	<a href="https://github.com/drift-labs/protocol-v2/blob/c6056d55cbdbc9e33583fc30a51e10d3a3faf724/programs/drift/src/state/perp_market.rs#L553-L565">Drift v2</a>
	provides TWAPs, but Drift is for perpetual swaps, not just any ol' tokens. 

    <p>
    	My first instinct was to see if I could modify an existing CLOB to provide
	TWAPs. Searching through Serum's repo, I found a planned feature called
	<a href="https://github.com/project-serum/serum-dex/blob/master/dex/tests/permissioned/programs/permissioned-markets/src/lib.rs">permissioned markets</a>.
	The idea with permissioned markets is markets would have some
	'open orders authority' who would need to sign off on all orders. This
	could be used to force all of that market's trades to be conducted
	through a wrapping program which holds a open orders authority
	PDA. I think the original intent here was to allow KYC-friendly projects
	to maintain whitelists on who's allowed to trade their token. But
	whatever the Creator(s) intended, I realized I could use it to create a
	TWAP. Because I could force all trades to go through a wrapper program,
	I could have that wrapper program record all trades. And if I could record
	all trades, constructing a TWAP would be easy peasy lemon squeezy.

    <p>
    	There was just one hitch in this plan. Permissioned markets were planned
	to be released in Serum v4. But before v4 could be released,
	<a href="https://abcnews.go.com/Business/timeline-cryptocurrency-exchange-ftxs-historic-collapse/story?id=93337035">that bad thing happened</a>.
	So TWAPs on Serum weren't going to work.

    <p>
    	But Lady Fortuna wasn't all against me: OpenBook, the spiritual successor
	to Serum, had an <a href="https://github.com/openbook-dex/openbook-v2/issues/33">open issue</a>
	for permissioned markets. So I just had to go about implementing it. Thanks
	to Very Cool Dude™ named
	<a href="https://twitter.com/binyebarwe?s=20">Binwe</a>,
	<a href="https://github.com/openbook-dex/openbook-v2/pull/46">I was able to get a PR merged</a>

    <p>
    	Now, it was on to the second half of the task: building the wrapper program
	that would provide the TWAP. Or was it? You see, there is a siren song
	that afflicts all engineers and prevents us from getting useful things done.
	It goes something like ♫<i>roll your own, baby</i>♫, and man is it a hard
	song to tune out. What if I wrote my own CLOB, one with an integrated
	TWAP? Could I build something that was both simpler and more performant than
	what was already out there?

    <p>
    	Although I can sometimes resist being seduced by the siren, this was not
	one of those times. The upshot of this is that I now, after 1.5 months of effort,
	have an answer to this question: yes, I can *pats self on back*. YALOB is both more simple
	and more performant than existing CLOBs. As far as simplicity goes,
	YALOB is ~1k lines of code, compared to Serum's 11.5k, Openbook's 12k,
	and Phoenix's 10.5k. It also uses a linked list to manage orders, rather than
	the more complex red-black tree or radix tree. And performance doesn't suffer
	either! The most important operations in any order book are limit order
	creates and deletes because for every limit order that is filled, ~100 are
	placed. Creating limit orders consumes
	<a href="https://twitter.com/aeyakovenko/status/1680603953493590016?s=20">7k CUs in Serum (according to Toly)</a>,
	<a href="https://xray.helius.xyz/tx/3WVGW8aFZkPxXaj8zqZH34SWqB7HBd5KryRKgz93tB2j5XQaKZJkEaqTxo96i53Vn17rvAgKMdiHM8vK1Ete85E1">20k CUs in Phoenix</a>, 
	~30k CUs in Openbook on the latest master (although this is subject to change,
	since it's not in prod yet). Because YALOB uses a linked-list, creating limit
	orders isn't constant-time, but a typical access pattern would consume less
	than 4k CUs on average and 5.7k CUs in the worst case. I didn't look at how
	many CUs the others consume to cancel an order, but since they use trees
	I would guess that deletion consumes roughly the same amount as insertion.
	But for YALOB, cancels are super cheap: 2.9k CUs! For reference, token transfers
	clock in at around 4.2k CUs! I'm not going to argue that all of this is a free
	lunch. Some of the trade-offs that YALOB makes are having a maximum of ~100
	orders on each side of the book instead of the typical ~1000 and not including
	features like automatically-expiring and oracle-pegged orders. But it
	<i>does</i> have a TWAP!

    <p>
    	My main take-away from this experience is that <i>it is possible to create
	Solana programs that are both very simple and very performant.</i>
	I wrote YALOB in <a href="https://www.anchor-lang.com/">Anchor</a>,
	which supposedly adds bloat. I only used <a href="https://godbolt.org/">Godbolt</a>
	to inspect the generated machine code once. I didn't do any of <a href="https://github.com/Uniswap/v4-core/blob/309610525547f53c526014928d6ceb8803485e26/contracts/libraries/TickMath.sol#L42-L76">the disgusting optimizations that EVM programs are forced to do</a>.
	All I did was focus on three things: getting the data structures right,
	keeping structs small, and writing simple code. The result was a performant
	program. If you follow the same steps, my money is on you getting the same output.

</html>
